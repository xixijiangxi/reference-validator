# 参考文献检索策略详细说明文档

## 目录

1. [概述](#概述)
2. [检索策略架构](#检索策略架构)
3. [优先级策略详解](#优先级策略详解)
4. [相似度计算机制](#相似度计算机制)
5. [设计原理与优势](#设计原理与优势)
6. [实际应用场景](#实际应用场景)
7. [性能优化措施](#性能优化措施)

---

## 概述

本应用的检索策略采用**分层递进、从精确到模糊**的设计理念，通过多优先级策略和智能相似度评估，在保证**精确度**的同时提高**召回率**，确保能够找到与原始参考文献最匹配的文献。

### 核心设计原则

1. **唯一标识符优先**：DOI和PMID是最可靠的标识符，优先使用
2. **多字段组合**：使用多个字段组合提高检索精确度
3. **从精确到模糊**：先尝试精确匹配，失败后再尝试模糊匹配
4. **实时相似度评估**：在检索过程中实时计算相似度，提前返回高置信度结果
5. **智能返回策略**：根据相似度分数智能决定返回结果数量

---

## 检索策略架构

### 整体流程图

```
输入关键词
    ↓
优先级0: PMID直接搜索
    ↓ (未找到)
优先级1: DOI搜索
    ↓ (未找到)
优先级2: 精确匹配 + 多字段组合
    ├─ 2a: 标题+作者+期刊+年份
    ├─ 2b: 标题+期刊+年份
    ├─ 2c: 标题+作者
    └─ 2d: 标题
    ↓ (未找到或结果不唯一)
优先级2b: 长标题处理（如果标题>15词）
    ↓ (未找到)
优先级3: 模糊匹配 + 多字段组合
    ├─ 3a: 关键词+作者+期刊+年份
    ├─ 3b: 关键词+期刊+年份
    ├─ 3c: 关键词+作者
    └─ 3d: 关键词
    ↓
优先级4: 相似度排序和智能返回
    ├─ 高置信度 (>0.9): 返回1篇
    ├─ 中等置信度 (0.7-0.9): 返回2篇
    └─ 低置信度 (<0.7): 返回3篇
```

---

## 优先级策略详解

### 优先级0: PMID直接搜索

**触发条件**: 关键词中包含 `pmid` 字段

**实现逻辑**:
```python
if keywords.get("pmid"):
    pmid = str(keywords["pmid"]).strip()
    article = await self.fetch_article_details(pmid)
    if article:
        return [article]  # 直接返回，跳过所有搜索
```

**设计原因**:
- **最可靠**: PMID是PubMed的唯一标识符，100%准确
- **最快速**: 直接获取文章详情，无需搜索步骤
- **避免误匹配**: 跳过所有搜索逻辑，避免找到错误的文章

**适用场景**:
- 参考文献中明确包含PMID
- 用户手动输入了PMID

---

### 优先级1: DOI搜索

**触发条件**: 关键词中包含 `doi` 字段

**实现逻辑**:
```python
if keywords.get("doi"):
    # 清理DOI格式
    doi = doi.strip().replace("https://doi.org/", "").replace("doi:", "").strip()
    # 使用 DOI[DOI] 字段搜索
    pmid = await self.search_by_doi(doi)
    if pmid:
        article = await self.fetch_article_details(pmid)
        return [article]  # 直接返回
```

**设计原因**:
- **高可靠性**: DOI是数字对象唯一标识符，几乎唯一确定一篇文章
- **标准化**: DOI格式统一，易于处理
- **快速**: 通常只返回一个结果，无需进一步筛选

**适用场景**:
- 参考文献中包含DOI
- 现代期刊文章通常都有DOI

---

### 优先级2: 精确匹配 + 多字段组合

**触发条件**: 关键词中包含 `title` 字段

**策略列表**（按可靠性从高到低）:

#### 2a: 标题 + 第一作者 + 期刊 + 年份

**查询格式**:
```
"标题"[Title] AND "第一作者"[Author] AND "期刊"[Journal] AND 年份[Publication Date]
```

**设计原因**:
- **最高精确度**: 四个字段组合几乎唯一确定一篇文章
- **避免误匹配**: 即使标题相似，通过作者、期刊、年份可以区分

**适用场景**:
- 参考文献信息完整
- 需要高精确度匹配

#### 2b: 标题 + 期刊 + 年份

**查询格式**:
```
"标题"[Title] AND "期刊"[Journal] AND 年份[Publication Date]
```

**设计原因**:
- **高精确度**: 三个字段组合通常能唯一确定文章
- **容错性**: 如果作者信息不完整，仍能准确匹配

**适用场景**:
- 缺少作者信息
- 期刊和年份信息完整

#### 2c: 标题 + 第一作者

**查询格式**:
```
"标题"[Title] AND "第一作者"[Author]
```

**设计原因**:
- **中等精确度**: 两个字段组合，适合信息不完整的情况
- **平衡**: 在精确度和召回率之间取得平衡

**适用场景**:
- 缺少期刊或年份信息
- 标题和作者信息完整

#### 2d: 标题（单独）

**查询格式**:
```
"标题"[Title]
```

**设计原因**:
- **基础策略**: 当其他信息都缺失时的最后选择
- **召回率高**: 能找到所有标题匹配的文章

**适用场景**:
- 只有标题信息
- 其他字段都缺失

**实时相似度评估**:
在优先级2的每个策略中，找到结果后会立即计算相似度：
- 如果相似度 > 0.9：立即返回最佳匹配（高置信度）
- 如果结果唯一：直接返回
- 如果结果多个：继续尝试更精确的策略

---

### 优先级2b: 长标题处理

**触发条件**: 标题超过15个词，且精确匹配未找到结果

**实现逻辑**:
```python
if len(title_words) > 15:
    short_title = " ".join(title_words[:15])
    # 尝试使用前15个词搜索
    pmids = await self.search_by_title(short_title, exact_match=True)
    # 同时尝试带期刊的搜索
    if journal:
        pmids_with_journal = await self.search_by_title(short_title, journal=journal, exact_match=True)
        pmids = list(set(pmids + pmids_with_journal))
```

**设计原因**:
- **处理长标题**: PubMed对标题长度有限制，长标题可能导致搜索失败
- **保留关键信息**: 标题的前15个词通常包含核心信息
- **多策略尝试**: 同时尝试带/不带期刊的搜索，提高召回率

**适用场景**:
- 标题非常长（>15个词）
- 精确匹配失败

---

### 优先级3: 模糊匹配 + 多字段组合

**触发条件**: 精确匹配未找到结果，且标题存在

**关键词提取**:
```python
# 提取标题关键词（去除停用词）
stop_words = {'the', 'a', 'an', 'and', 'or', 'for', 'of', 'in', 'on', 'at', 'to', 'by', 'with', 'is', 'are', 'was', 'were'}
keywords_list = [w for w in title_words if w.lower() not in stop_words and len(w) > 2]
key_title = " ".join(keywords_list[:10])  # 最多使用10个关键词
```

**策略列表**（按可靠性从高到低）:

#### 3a: 关键词 + 第一作者 + 期刊 + 年份

**查询格式**:
```
(关键词1 AND 关键词2 AND ...)[Title] AND "第一作者"[Author] AND "期刊"[Journal] AND 年份[Publication Date]
```

**设计原因**:
- **处理格式差异**: 关键词匹配可以处理标题格式差异
- **多字段约束**: 通过作者、期刊、年份缩小范围

#### 3b: 关键词 + 期刊 + 年份

**查询格式**:
```
(关键词1 AND 关键词2 AND ...)[Title] AND "期刊"[Journal] AND 年份[Publication Date]
```

#### 3c: 关键词 + 第一作者

**查询格式**:
```
(关键词1 AND 关键词2 AND ...)[Title] AND "第一作者"[Author]
```

#### 3d: 关键词（单独）

**查询格式**:
```
(关键词1 AND 关键词2 AND ...)[Title]
```

**设计原因**:
- **提高召回率**: 当精确匹配失败时，模糊匹配能找到相似文章
- **处理格式差异**: 关键词匹配可以处理标题中的格式差异、大小写差异等
- **逐步放宽**: 从多字段到少字段，逐步放宽约束

**适用场景**:
- 精确匹配失败
- 标题格式与PubMed中的格式有差异
- 标题中有拼写错误或缩写

---

### 优先级4: 相似度排序和智能返回

**触发条件**: 找到多个结果

**实现逻辑**:
```python
# 计算所有结果的相似度
scored_results = []
for article in results:
    similarity = similarity_service.calculate_similarity(keywords, article_keywords)
    scored_results.append((similarity, article))

# 按相似度排序
scored_results.sort(key=lambda x: x[0], reverse=True)

# 智能返回策略
best_score = scored_results[0][0]
if best_score > 0.9:
    return [scored_results[0][1]]  # 高置信度：返回1篇
elif best_score > 0.7:
    return [article for _, article in scored_results[:2]]  # 中等置信度：返回2篇
else:
    return [article for _, article in scored_results[:3]]  # 低置信度：返回3篇
```

**设计原因**:
- **智能筛选**: 根据相似度分数决定返回结果数量
- **用户体验**: 高置信度时只返回1篇，避免用户困惑
- **灵活性**: 低置信度时返回多篇，让用户选择

**返回策略**:

| 相似度范围 | 返回数量 | 说明 |
|-----------|---------|------|
| > 0.9 | 1篇 | 高置信度，几乎确定是同一篇文章 |
| 0.7 - 0.9 | 2篇 | 中等置信度，可能是同一篇，返回最可能的2篇 |
| < 0.7 | 3篇 | 低置信度，返回最可能的3篇供用户选择 |

---

## 相似度计算机制

### 权重配置

相似度计算采用**加权平均**的方式，不同字段有不同的权重：

| 字段 | 权重 | 说明 |
|------|------|------|
| DOI | 30% | 最高权重，完全匹配直接返回100% |
| PMID | 25% | 唯一标识符，高可靠性 |
| 标题 | 20% | 文章的核心标识 |
| 作者 | 15% | 作者信息，中等重要性 |
| 期刊 | 5% | 期刊信息，辅助判断 |
| 年份 | 3% | 年份信息，辅助判断 |
| 卷号 | 1% | 细节信息，权重较低 |
| 期号 | 1% | 细节信息，权重较低 |
| 页码 | 0% | 不参与相似度计算 |

**设计原因**:
- **DOI/PMID优先**: 唯一标识符最可靠，权重最高
- **标题重要**: 标题是文章的核心标识，权重较高
- **作者辅助**: 作者信息有助于区分相似标题的文章
- **其他字段辅助**: 期刊、年份等字段作为辅助判断依据

### 计算流程

#### 1. DOI完全匹配检查

```python
if original.get("doi") and matched.get("doi"):
    if original["doi"].lower().strip() == matched["doi"].lower().strip():
        return 1.0  # 100%匹配，直接返回
```

**设计原因**:
- **唯一性**: DOI完全匹配意味着是同一篇文章
- **快速判断**: 无需计算其他字段的相似度

#### 2. 各字段相似度计算

**标题相似度**:
```python
def _text_similarity(text1: str, text2: str) -> float:
    # 标准化文本（转小写、去空格）
    text1 = text1.lower().strip()
    text2 = text2.lower().strip()
    
    if text1 == text2:
        return 1.0
    
    # 使用SequenceMatcher计算相似度
    return SequenceMatcher(None, text1, text2).ratio()
```

**作者相似度**:
```python
def _authors_similarity(authors1: List[str], authors2: List[str]) -> float:
    # 标准化作者名称
    authors1_normalized = [normalize_author(a) for a in authors1]
    authors2_normalized = [normalize_author(a) for a in authors2]
    
    # 计算第一作者匹配度（权重50%）
    first_author_sim = self._text_similarity(
        authors1_normalized[0],
        authors2_normalized[0]
    )
    
    # 计算所有作者的匹配度（权重50%）
    matched = 0
    for a1 in authors1_normalized:
        for a2 in authors2_normalized:
            if self._text_similarity(a1, a2) > 0.8:
                matched += 1
                break
    
    avg_match = matched / max(len(authors1_normalized), len(authors2_normalized))
    
    # 综合相似度：第一作者50% + 整体匹配50%
    return (first_author_sim * 0.5 + avg_match * 0.5)
```

**设计原因**:
- **第一作者重要**: 第一作者通常是主要贡献者，权重较高
- **整体匹配**: 考虑所有作者的匹配情况，更全面
- **容错性**: 允许作者顺序不同、格式差异

#### 3. 加权平均计算

```python
total_score = 0.0
total_weight = 0.0

# 各字段相似度 × 权重
total_score += title_sim * self.weights["title"]
total_weight += self.weights["title"]

# ... 其他字段

# 最终相似度 = 总得分 / 总权重
final_similarity = total_score / total_weight
```

**设计原因**:
- **加权平均**: 不同字段的重要性不同，使用加权平均更合理
- **归一化**: 除以总权重，确保结果在0-1之间
- **灵活性**: 如果某个字段缺失，只计算存在的字段

---

## 设计原理与优势

### 1. 分层递进策略

**原理**: 从最精确到最模糊，逐步放宽约束条件

**优势**:
- **效率高**: 精确匹配成功时立即返回，避免不必要的搜索
- **精确度高**: 优先使用多字段组合，提高匹配准确度
- **召回率高**: 模糊匹配作为后备，确保能找到文章

### 2. 多字段组合

**原理**: 使用多个字段组合，提高检索的精确度

**优势**:
- **唯一性**: 多个字段组合通常能唯一确定一篇文章
- **容错性**: 即使某个字段有误差，其他字段可以弥补
- **可靠性**: 字段越多，匹配的可靠性越高

### 3. 实时相似度评估

**原理**: 在检索过程中实时计算相似度，提前返回高置信度结果

**优势**:
- **快速响应**: 找到高置信度结果时立即返回，无需继续搜索
- **减少API调用**: 避免不必要的PubMed API调用
- **用户体验**: 用户能更快看到结果

### 4. 智能返回策略

**原理**: 根据相似度分数智能决定返回结果数量

**优势**:
- **减少噪音**: 高置信度时只返回1篇，避免用户困惑
- **灵活性**: 低置信度时返回多篇，让用户选择
- **用户体验**: 根据置信度调整返回数量，更符合用户期望

### 5. 格式容差处理

**原理**: 通过模糊匹配和相似度计算处理格式差异

**优势**:
- **容错性**: 能处理标题格式差异、大小写差异等
- **适应性**: 适应不同来源的参考文献格式
- **召回率**: 提高找到文章的概率

---

## 实际应用场景

### 场景1: 完整信息 + DOI

**输入**:
```json
{
  "title": "The China Alzheimer Report 2022",
  "authors": ["Ren R", "Qi J"],
  "journal": "Gen Psychiatr",
  "year": 2022,
  "doi": "10.1136/gpsych-2022-100751"
}
```

**检索流程**:
1. 优先级1: DOI搜索 → 找到PMID → 获取文章详情
2. **返回**: 1篇文章（最快，最可靠）

**预期结果**: 相似度 = 1.0，直接返回

---

### 场景2: 完整信息（无DOI）

**输入**:
```json
{
  "title": "The China Alzheimer Report 2022",
  "authors": ["Ren R", "Qi J"],
  "journal": "Gen Psychiatr",
  "year": 2022
}
```

**检索流程**:
1. 优先级2a: 标题+作者+期刊+年份（精确匹配）
2. 找到结果，计算相似度 = 0.95
3. **返回**: 1篇最佳匹配（高置信度）

**预期结果**: 相似度 > 0.9，返回1篇

---

### 场景3: 部分信息

**输入**:
```json
{
  "title": "The China Alzheimer Report 2022",
  "journal": "Gen Psychiatr",
  "year": 2022
}
```

**检索流程**:
1. 优先级2b: 标题+期刊+年份（精确匹配）
2. 找到3篇结果，计算相似度 = [0.85, 0.72, 0.65]
3. **返回**: 前2篇（中等置信度）

**预期结果**: 相似度 0.7-0.9，返回2篇

---

### 场景4: 格式差异

**输入**:
```json
{
  "title": "Machine Learning in Medical Research",
  "authors": ["Li, X"]
}
```

**PubMed中的标题**: "Machine Learning in Medical Research: A Comprehensive Review"

**检索流程**:
1. 优先级2c: 标题+作者（精确匹配）→ 未找到
2. 优先级3c: 关键词+作者（模糊匹配）
3. 找到结果，计算相似度 = 0.78
4. **返回**: 前2篇（中等置信度）

**预期结果**: 通过模糊匹配找到，相似度 0.7-0.9

---

### 场景5: 长标题

**输入**:
```json
{
  "title": "A Comprehensive Review of Machine Learning Applications in Medical Research: From Diagnosis to Treatment and Beyond",
  "journal": "Nature Medicine"
}
```

**检索流程**:
1. 优先级2d: 标题（精确匹配）→ 未找到（标题太长）
2. 优先级2b: 使用前15个词 + 期刊
3. 找到结果，计算相似度 = 0.82
4. **返回**: 前2篇（中等置信度）

**预期结果**: 通过长标题处理找到

---

## 性能优化措施

### 1. 提前返回机制

**实现**:
- 找到高置信度结果（相似度>0.9）时立即返回
- 结果唯一时直接返回，无需继续搜索

**效果**:
- 减少不必要的API调用
- 提高响应速度
- 降低服务器负载

### 2. 去重机制

**实现**:
```python
seen_pmids = set()
for pmid in pmids:
    if pmid not in seen_pmids:
        # 处理文章
        seen_pmids.add(pmid)
```

**效果**:
- 避免重复获取同一篇文章
- 减少API调用次数
- 提高效率

### 3. 智能跳过无效策略

**实现**:
```python
if strategy_name == "标题+作者+期刊+年份" and not (a and j and y):
    continue  # 跳过无效策略
```

**效果**:
- 避免无效的API调用
- 提高检索效率
- 减少错误日志

### 4. 延迟导入

**实现**:
```python
# 延迟导入避免循环依赖
from app.services.similarity_service import SimilarityService
similarity_service = SimilarityService()
```

**效果**:
- 避免循环依赖
- 提高模块加载速度
- 更好的代码组织

---

## 总结

本应用的检索策略通过**分层递进、多字段组合、实时评估、智能返回**的设计，实现了：

1. **高精确度**: 优先使用唯一标识符和多字段组合
2. **高召回率**: 模糊匹配作为后备，确保能找到文章
3. **高效率**: 提前返回机制和去重机制减少不必要的操作
4. **好体验**: 智能返回策略根据置信度调整返回数量

这种设计能够在各种场景下都能找到最匹配的文献，同时保证检索的效率和用户体验。

